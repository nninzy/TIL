# JS - Basic Syntax of Javascript

강의 날짜: 2023/03/14

강의처: KDT

기록 날짜: 2023/04/06

세줄 요약: 변수 선언 키워드 / 원시 데이터 타입 / 연산자 / 조건문과 반복문 ⇒ (과제) for in과 for of MDN에서 찾기

주제: JS

강의필기: [0314 KDT 강의 필기](/Lecture/multicampus_KDT_2nd/lecture_note/0314_KDT_JS_DAY2.pdf)

- 페이지 목차

---

### Intro

- TIP. “우리 수업에서는 JS에 관련해서 브라우저 조작용으로만 배운다”
    - 프로그래밍 언어로 JS를 학습하고자 한다면 추가 학습이 필요하다.
        - MDN 내 학습 Guide, Tutorial 등을 참고하는 것을 추천한다.
        특히 reference에는 자습서 입문부터 중급까지 단계가 나눠진 편
        - MDN에는 plus라는 구독 서비스도 있다, 현재는 무료
        - MDN 계정이나 github 계정을 연동해두면 MDN의 번역에 참여할 수 있고, Contributor에 이름도 남는다.

- 수업 큰 그림 그리기 (지난 시간까지의 내용)
    - HTML / CSS =
    구조와 스타일.
    현재의 CSS는 발전을 이뤄서 애니메이션까지는 가능하지만, 정적인 형태.
    - Javascript =
    사용자의 반응에 따른 움직임 (동적인 요소)을 주는 역할.
    HTML과 CSS 문서를 브라우저 내 JS 내장 엔진을 파싱해 조작한다.
    이때, 접근은 DOM API를 통해 객체로 접근한다.
    HTML의 객체는 트리구조 (부모 - 자식 관계를 갖는 형태)로 이뤄져 있으며, 가장 최상위는 document이다
    (물론 그보다 더 위의 window도 있으나 우리가 window를 조작할 일은 없다)

---

### 이번 수업의 목차

1. 개요
2. 변수
3. 데이터타입
4. 연산자
5. 조건문
6. 반복문

### 학습 목표

- let, const 등의 **변수 키워드**에 따라 적절히 값을 할당하여 다양한 데이터를 다룰 수 있다.
- **연산자**를 활용하여 다양한 계산을 수행할 수 있다.
- if-else 문 (**조건문**)을 활용해 조건에 따라 다른 동작을 수행할 수 있도록 한다.
- for문, while문 등 다양한 **반복문**을 사용해 반복적인 작업을 수행할 수 있다.

---

### 개요 - 시작하기 전에

- 최근에 많이 사용하는 JS 관련은 ES6 이후의 명제들이다. 하지만 레거시의 경우 변경할 경우 큰 문제가 발생할 수 있기에 MDN 문서 등을 볼 때 잘 필터링해서 보자.
- JS는 파이썬 공식문서와 같이 정해진 스타일이 정해져 있지 않으며, 몇가지 유명한 style guide가 있다.
우리는 그 중 standardjs.com의 코딩 스타일 가이드를 따른다. (ex. 2칸 공백 / 문자열은 작은 따옴표 사용 / if, function 등의 예약어을 사용한 뒤에는 공백으로 구분한다 등)

---

## 변수

### 식별자 (변수명) 작성 규칙

- 변수명 시작할 때 == 반드시 문자, 달러($) 또는 밑줄(_)로 시작한다.
- 변수명은 대소문자를 구분하며, 클래스 이외에는 소문자로 시작한다.
- for, if, function 등의 예약어는 사용할 수 없다.

<aside>
❗ **JS 변수명 작성 종류별 사용 CASE**

- **카멜 케이스 (camelCase)** = 변수 시작 소문자 / 단어 구분 대문자
**변수 / 객체 / 함수 (대부분의 케이스가 여기 해당, 기본)**에 사용
- **파스칼 케이스 (PascalCase)** = 변수 시작과 단어 구분 모두 대문자
**클래스 / 생성자**에 사용
- **대문자 스네이크 케이스 (SNAKE_CASE)** = 모두 대문자 / 단어 구분 밑줄(_)
**상수 (constants, 개발자 의도와 상관없이 변경 가능성 X값)**에 사용
ex. API_KEY
</aside>

<참고>

[상수와 변수](https://www.notion.so/7e69f28da25f45328f695f8adc356561) 

### 변수 선언 키워드

- JS는 변수 선언 키워드에 따라 변수의 특징이 달라진다.
    - JS에서 변수 선언을 구분한 이유
        - 변수의 재할당과 재선언이 자주 일어날 경우, 코드의 유지 보수, 디버깅 측면에서 좋지 않다.
        각각의 변수는 하나의 역할만 하는 것이 가장 좋기에 JS는 이런 상황을 키워드로 막은 것.
        - 하지만 구조상 재할당이 필요한 경우가 있기에 let이라는 변수 키워드가 존재하는 것이다.
- 변수 선언 키워드로는 총 3가지가 있다 ⇒ var / let / const
이 중 var은 더 이상 사용하지 않으며, 기본적으로는 const 사용을 권장한다.
let은 일반 for문, while문(반복하며 값 재할당 필요)과 같이 재할당이 필요한 경우만 사용한다.

<aside>
❗ **let (ES6에서 추가)**

`재할당 가능` , `재선언 불가능`⇒ 선언 이후 값 변경 가능

블록스코프를 갖는 지역 변수를 선언 (중괄호 외부에서 변수 접근 불가능)

값 없이도 변수명만 선언이 가능하다,
이때는 원시 데이터 타입인 undefined가 자동으로 할당된다. (하지만 이렇게 쓰진 않음)

</aside>

<aside>
❗ **const (ES6에서 추가)**

`재할당 불가능`, `재선언 불가능` ⇒ 한번 선언 이후 값 변경 불가

블록스코프를 갖는 지역 변수를 선언 (중괄호 외부에서 변수 접근 불가능)

선언 시 반드시 초기값 설정 필요 (값 없이 선언 불가)
`const’ declarations must be initialized.` 라는 에러메시지 뜸

</aside>

<참고>

[스코프](https://www.notion.so/e497e642cd0a411786fb8cdea4ba1496) 

---

## 데이터 타입

### ‘원시 자료형’과 ‘참조 자료형’

- 원시 자료형 (Primative type)
= 변수에 값이 직접 저장되는 자료형 (불변, 수정 X, 값이 복사)
= 변수 내 값 변화는 변수 재할당으로 진행된다.
    - **Number (숫자)**
    - **문자열(String)**
    - **불리언(Boolean)**
    - **Undefined와 null**

- 참조 자료형 (Reference type)
    - Objects
    = 객체의 주소가 저장되는 자료형 (가변, 수정 O, 주소가 복사)
    = 변수 내 값 변화는 주소가 의미하는 데이터 공간의 값 수정으로 진행된다.
        
        = 원시 자료 형태를 제외한 나머지, 객체 형태라고도 한다.
        내부적으로는 key, value의 형태를 갖고 있는 것들이 여기에 해당한다.
        
        - Object (Python의 dictionary 같은 것)
        - Array (Python의 list와 동일)
        - Function

### 원시 자료형

- **Number** = 정수 또는 실수형 숫자를 표현하는 자료형
    - 정수, 실수, -0, Infinity, -Infinity, NaN (Not a Number)등이 여기에 해당한다.
    
    <aside>
    ❗ **NaN (Not a Number)**
    
    - 결과로 만나는 값으로, 사용자가 직접 입력하는 경우는 거의 없다 (조건식 등)
    - NaN 반환 Case 예시
        - 숫자로서 읽을 수 없음 ⇒ Number(undefined)
        - 결과가 허수인 수학 계산식 ⇒ Math.sqrt(-1)
        - 피연산자가 NaN ⇒ 7 ** NaN
        - 정의할 수 없는 계산식 ⇒ 0 * Infinity
        - 문자열을 포함하면서 덧셈이 아닌 계산식 ⇒ ‘가’ / 3
        
    </aside>
    

- **String** = 텍스트 데이터를 표현하는 자료형
    - 텍스트데이터는 큰따옴표 (””)나 작은따옴표(’’)로 변수와 구분한다.
    (스타일 가이드에서는 작은따옴표를 사용한다)
    - 덧셈을 통해 문자열끼리 붙일 수 있지만, 곱셉 / 나눗셈 / 밸셈은 안된다.
    
    <aside>
    ❗ **Template Literal (템플릿 리터럴)**
    
    - 내장된 표현식을 허용하는 문자열 작성 방법
    (문자열 사이에 변수를 삽입하는 방법 / Python f-string과 같음, ES6+부터 지원)
    - 따옴표 대신 벡틱(``, backtick)를 사용해 표현하고,
    변수는 $와 중괄호를 사용해 ${변수명}로 사용한다.
    - Template literal 도입 이후 여러 줄에 걸쳐 문자열을 정의할 수 있고, JS의 변수를 문자열 안에 바로 연결할 수 있는 이점이 생겼다.
    </aside>
    
- **Boolean**
    
    = true와 false (python과 달리 첫글자 모두 소문자이다)
    
    - 조건문, 반복문에서 boolean이 아닌 데이터타입은 ‘자동형변환 규칙’에 따라 boolean으로 변환된다.
        
        <aside>
        ❗ **<자동 형변환. ToBoolean Conversations>**
        
        | 데이터타입 | false | true |
        | --- | --- | --- |
        | undefined 과 null | 항상 false | X |
        | Number | 0, -0, NaN | 그 외 |
        | String | 빈 문자열 | 그 외 |
        </aside>
        

- **Undefined**
    
    = 변수의 선언 이후 직접 값을 할당하지 않을 경우 ‘**자동’**으로 할당
    
    JS 내부적으로 쓰이는 값으로, 개발자가 쓸 수 있지만 null이 있기에 쓰지 않음
    

- **null**
    
    = 변수의 값이 없음을 ‘**의도적’**으로 표현할 때 사용
    

<aside>
❗ **원시자료형 null과 undefined**

- 동일한 역할을 하는 null과 undefined가 존재하는 이유는 단순 JS 설계 실수
- 특히 null은 원시 자료형임에도 불구하고 object로 출력되는 버그를 갖고 있음.
null type 의존성 프로그램들의 하위 호환 유지를 위해 없애지 못함
</aside>

---

## 연산자

### 할당 연산자 (=)

- 오른쪽에 있는 피연산자의 평가 결과를 왼쪽 피연산자에 할당하는 연산자
- 다양한 연산에 대한 단축 연산자 지원
    - `**+= n**`: 피연산자에 n만큼 더한 뒤 재할당
    - `**-= n**` : 피연산자에 n만큼 뺀 뒤 재할당
    - `***= n**`: 피연산자에 n만큼 곱한 뒤 재할당
    - `**/= n**`: 피연산자에 n만큼 나눈 뒤 재할당

<aside>
❗ **Increment와 Decrement**

- **Increment (++)**
    
    피연산자의 값을 1 증가시키는 연산자
    
- **Decrement (--)**
    
    피연산자의 값을 1 감소시키는 연산자
    

반복문 (일반 for문) 등에서 자주 볼 수 있다.

style guide에서는 `+= 1`, `-= 1`과 같이 더 분명한 표현으로 적어 보다 명시적인 표현을 할 것을 권장한다.

</aside>

### 비교 연산자 (>, <. ≥, ≤)

- 피연산자들 (숫자, 문자, Boolean 등)을 비교하고 결과값을 boolean으로 반환하는 연산자


### 논리 연산자 (&&, ||, !)

- **`&&`** : and 연산
- **`||`** : or 연산
- **`!`** : not 연산

### 동등 연산자 (==)

- 두 피연산자가 **같은 값**으로 **평가**되는지 비교 후 **boolean값을 반환** ⇒ 타입 상관없이 값만 비교
- 비교할 때 **‘암묵적 타입 변환’**을 통해 타입을 일치시킨 후 같은 값인지 비교
    
    **암묵적 타입 변환을 통해 예상치 못한 결과가 발생할 수 있으므로,
    특별할 경우를 제외하고는 사용하지 않음**
    
- 두 피연산자가 모두 객체일 경우, 메모리의 같은 객체를 바라보는지 판별

### 일치 연산자 (===)

- 두 피연산자의 **값**과 **타입**이 모두 같을 경우 true 반환
- 같은 객체를 가리키거나, 같은 타입이면서 같은 값인지를 비교한다.
- **엄격한 비교**가 이뤄지며, 암묵적 타입 변환이 발생하지 않는다.

---

## 조건문

### if-else 문

- 조건식의 결과값을 boolean 타입으로 변환 후 참/거짓을 판단한다.
- 형태
    
    > **`if`** + 공백 + **`( 조건문 )`** + 공백 + **`{ 명령문 }`
    `else if`** + 공백 + **`( 조건문 )`** + 공백 + **`{ 명령문 }`
    `else`** + 공백 + **`{ 명령문 }`**
    > 
    - 조건문은 참/거짓 판별이 가능해야 하며, 조건문이 참일 경우에만 명령문을 실행한다.
    - 명령문은 중괄호로 묶인 내용이므로, 블록스코프 단위이다.

---

## 반복문

(중괄호를 이용한 실행문이 있기에 블록 스코프에 해당한다)

### while문

- 조건문이 참이기만 하면 (false가 되기 전까지) 문장을 계속해서 수행
- 형태
    
    > **`while`** + 공백 + **`( 조건문 )`** + 공백 + **`{ 실행문 }`**
    > 
    - while문 내부 조건문에 쓰이는 변수는 반복 수행되는 작업이기에 const가 아닌 let만 사용한다.

<aside>
❗ **break & continue**

- while문과 일반 for문에서 적용 가능한 키워드
</aside>

### for문

- 특정한 조건이 거짓으로 판별될 때까지 반복
- 형태
    
    > **`for`** + 공백 + **`( 초기문; + 공백 + 조건문; + 공백 + 증감문 )`** + 공백 + **`{ 실행문 }`**
    > 
    - 소괄호 조건문 안에는 표현식이 3개 들어간다.
    각각의 표현식은 세미콜론 (;)과 공백을 이용해 구분한다.
    - 소괄호 조건문 안에 있는 초기문에는 변수 키워드 let를 이용해 최초 정의한다.
    **초기문의 변수는 재할당되며 반복 수행되는 작업이기에 const가 아닌 let만을 사용한다.
    (const를 사용하면 에러가 발생한다)**
- 일반 for문의 동작원리
    1. 초기문 실행
    2. 조건문 평가 후 참일 경우 실행문 코드블럭 실행
    3. 코드블록 실행 이후 증감문에 따라 초기변수 값 변화 / 2의 과정 반복
- 일반 for문은 단순 counting 개념의 증감식이 조건문이기에 요새는 for-in 이나 for-of를 많이 사용

### for … in

- 객체(Object - python의 dict와 같은 구조)의 속성(key)을 순회할 때 사용
= 객체의 속성에 대해 반복
= 목적이 명확한(객체에 대해 접근) 반복문
- 객체 전용의 for문이나 배열을 넣을 경우에도 동작하긴 하지만, index를 속성으로 인식해 작동한다.
(순서에 따라 인덱스 반환을 보장할 수 없기에 인덱스의 순서가 중요한 배열에서는 사용하지 않음)
- 형태
    
    > **`for`** + 공백 + `( variable **in object** )` + 공백 + **`{ 실행문 }`**
    > 
    - 조건문 내부에 있는 variable(변수)는 내부에서 변수 선언 키워드와 함께 사용된다.
    이때는 재할당이 아니라, 반복문의 다른 속성이름이 변수에 지정되는 것이기에
    const를 사용해도 에러가 발생하지 않으며, let도 사용 가능하다.
    

### for … of

- 반복 가능한 객체 (배열, 문자열 등 / 인덱스가 존재하는 객체)를 순회할 때 사용
= 객체의 요소(인덱스)에 대해 반복
= 객체 (object) 이외의 나머지 (배열, 문자열)에 대해 사용하는 반복문이다.
- for…of 문의 동작원리는 객체에 적용되지 않기에, 객체를 넣을 경우 동작하지 않는다.
- 형태
    
    > **`for`** + 공백 + `( variable **of iterable** )` + **`{ 실행문 }`**
    > 
    - 조건문 내부에 있는 variable(변수)는 내부에서 변수 선언 키워드와 함께 사용된다.
    이때는 재할당이 아니라, 반복문의 다른 속성이름이 변수에 지정되는 것이기에
    const를 사용해도 에러가 발생하지 않으며, let도 사용 가능하다.

---

## 참고

### 세미콜론

- 자바스크립트는 세미콜론을 선택적으로 사용 가능하다
- 세미콜론이 없을 경우 ASI에 의해 자동으로 세미콜론이 삽입되기 때문
    - ASI (Automatic Semicolon Insertion, 자동 세미콜론 삽입 규칙)
- 일반 for문 내 조건문과 같이 문장의 구분이 필요한 경우에는 세미콜론( ; )을 삽입해줘야 한다.

### 변수 키워드 var

- ES6 이전에 변수를 선언할 때 사용되던 변수 선언 키워드
- 변수 선언 시 var, const, let 키워드 중 하나를 사용하지 않으면 자동으로 var로 선언된다 ⇒ “변수 선언 키워드 잊지말자”
- 재할당과 재선언이 모두 가능하기에, 유지보수에 좋지 않고
호이스팅되는 특성으로 인해 예기치 못한 문제가 발생할 가능성이 있어 ES6 이후로는 const, let의 사용을 권장하고 있다.
    
    <aside>
    ❗ **호이스팅 (hoisting)**
    
    - 변수 선언 이전에 참조할 수 있는 현상으로, 실제 실행 시 변수들이 코드 최상단으로 끌어올려져 이러한 일이 발생한다.
    - 변수 선언 이전의 위치에서 해당 변수에 접근할 경우 undefined으로 값이 초기화되는 과정이 동시에 일어난다.
    - let과 const는 호이스팅이 일어날 경우 `Uncaught ReferenceError`를 발생시킨다.
    </aside>
    
- let, const와 같이 블록 스코프를 갖는 것이 아니라 함수 스코프 (function scope)를 가진다.
⇒ 조건문이나 반복문 등에서 var를 사용할 경우 외부에 var로 선언된 동일한 이름의 변수가 있을 경우 조건문/반복문 내부에 영향을 끼친다.
    - 함수 스코프 : 함수의 중괄호 내부를 가리키는 것으로, 함수 스코프를 가지는 변수는 함수 바깥에서 접근할 수 없다.